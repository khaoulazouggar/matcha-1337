(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react')) :
  typeof define === 'function' && define.amd ? define(['exports', 'react'], factory) :
  (global = global || self, factory(global.googleMapsReactHooks = {}, global.react));
}(this, (function (exports, React) {
  var React__default = 'default' in React ? React['default'] : React;

  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  // eslint-disable-next-line
  /// <reference types="@types/googlemaps" />

  /**
   * A Google Maps wrapper class
   */
  var GoogleMap = /*#__PURE__*/function () {
    function GoogleMap(options) {
      var _this = this;

      /**
       * Remove event listeners
       */
      this.destroyListeners = function () {
        if (_this.map) {
          google.maps.event.clearInstanceListeners(_this.map);
        }
      };
      /**
       * Remove map instance
       */


      this.destroyComplete = function () {
        if (_this.map) {
          document.querySelectorAll('script[src^="https://maps.googleapis.com"]').forEach(function (script) {
            script.remove();
          });

          if (window.google && window.google.maps) {
            delete window.google.maps;
          }
        }
      };

      if (window.google && window.google.maps) {
        this.initMap(options);
      } else {
        this.loadGoogleScript(options);
      }
    }
    /**
     * Loads the google maps script
     */


    var _proto = GoogleMap.prototype;

    _proto.loadGoogleScript = function loadGoogleScript(options) {
      var _this2 = this;

      var scriptTag = document.createElement('script');
      var defaultLanguage = window.navigator.language.slice(0, 2);
      var defaultRegion = window.navigator.language.slice(3, 5);
      scriptTag.setAttribute('type', 'text/javascript');
      scriptTag.setAttribute('src', "https://maps.googleapis.com/maps/api/js?key=" + options.googleMapsAPIKey + "&language=" + (options.language || defaultLanguage) + "&region=" + (options.region || defaultRegion) + (options.libraries ? "&libraries=" + options.libraries.join(',') : '') + (options.mapIds ? "&map_ids=" + options.mapIds.join(',') : ''));

      scriptTag.onload = function () {
        options.onLoadScript();

        _this2.initMap(options);
      };

      document.getElementsByTagName('head')[0].appendChild(scriptTag);
    }
    /**
     * Initialize the google map
     */
    ;

    _proto.initMap = function initMap(options) {
      var _this3 = this;

      var container = options.container,
          config = options.config;
      this.container = container;
      this.map = new google.maps.Map(this.container, config);
      google.maps.event.addListenerOnce(this.map, 'idle', function () {
        _this3.map && options.onLoadMap(_this3);
      });
    };

    return GoogleMap;
  }();

  /**
   * The map context
   */

  var GoogleMapContext = React__default.createContext({
    loading: true
  });
  /**
   * The global Google Map provider
   */

  var GoogleMapProvider = function GoogleMapProvider(props) {
    var children = props.children,
        googleMapsAPIKey = props.googleMapsAPIKey,
        mapContainer = props.mapContainer,
        options = props.options,
        libraries = props.libraries,
        language = props.language,
        region = props.region,
        mapIds = props.mapIds,
        onLoad = props.onLoad;

    var _useState = React.useState(true),
        loading = _useState[0],
        setLoading = _useState[1];

    var _useState2 = React.useState(),
        map = _useState2[0],
        setMap = _useState2[1];

    var createGoogleMap = function createGoogleMap() {
      if (!mapContainer) {
        return;
      }

      var mapOptions = {
        container: mapContainer,
        googleMapsAPIKey: googleMapsAPIKey,
        onLoadScript: function onLoadScript() {
          return setLoading(false);
        },
        onLoadMap: function onLoadMap(loadedMap) {
          setMap(loadedMap);

          if (typeof onLoad === 'function' && loadedMap.map) {
            onLoad(loadedMap.map);
          }
        },
        config: options,
        libraries: libraries,
        mapIds: mapIds,
        language: language,
        region: region
      }; // Create Google Map instance

      new GoogleMap(mapOptions);
    }; // Destroy Google Map when component unmounts


    React.useEffect(function () {
      return map && map.destroyComplete();
    }, []); // Destroy and recreate map on mapcontainer change

    React.useEffect(function () {
      if (!mapContainer) {
        return;
      }

      if (map) {
        // Destroy old map instance listeners
        map.destroyListeners();
      } // create new map instance


      createGoogleMap();
    }, [mapContainer]); // Destroy and recreate map on language or region change

    React.useEffect(function () {
      if (!map) {
        return;
      } // Destroy old map instance


      map.destroyComplete(); // create new map instance

      createGoogleMap();
    }, [language, region]);
    return React__default.createElement(GoogleMapContext.Provider, {
      value: _extends({}, map, {
        loading: loading
      })
    }, children);
  };

  /**
   * Hook to get global map instance
   */

  var useGoogleMap = function useGoogleMap() {
    return React.useContext(GoogleMapContext);
  };

  /**
   * Hook to get Google Maps Places Service instance
   */

  var usePlacesService = function usePlacesService() {
    var _useGoogleMap = useGoogleMap(),
        map = _useGoogleMap.map; // Creates a Places Service instance


    var placesService = React.useMemo(function () {
      // Wait for map to be initialized
      if (!map) {
        return null;
      }

      if (!google.maps.places) {
        throw Error("Places library missing. Add 'places' to the libraries array of GoogleMapProvider.");
      }

      return new google.maps.places.PlacesService(map);
    }, [map]);
    return placesService;
  };

  /**
   * Hook to get a Google Maps Places Autocomplete instance
   * monitoring an input field
   */

  var useAutocomplete = function useAutocomplete(props) {
    var inputField = props.inputField,
        options = props.options,
        onPlaceChanged = props.onPlaceChanged;
    var placeChangedHandler = React.useRef(onPlaceChanged);

    var _useGoogleMap = useGoogleMap(),
        map = _useGoogleMap.map;

    var _useState = React.useState(null),
        autocomplete = _useState[0],
        setAutocomplete = _useState[1]; // Initializes the Google Maps Places Autocomplete


    React.useEffect(function () {
      // Wait for map and input element to be initialized
      if (!map || !inputField) {
        return function () {};
      }

      if (!google.maps.places) {
        throw Error("Autocomplete library missing. Add 'places' to the libraries array of GoogleMapProvider.");
      } // Create Autocomplete instance


      var autocompleteInstance = new google.maps.places.Autocomplete(inputField, options);
      setAutocomplete(autocompleteInstance); // Add places change listener to Autocomplete

      autocompleteInstance.addListener('place_changed', function () {
        var place = autocompleteInstance.getPlace();
        placeChangedHandler.current && placeChangedHandler.current(place);
      }); // Clear listeners on unmount

      return function () {
        autocompleteInstance && google.maps.event.clearInstanceListeners(autocompleteInstance);
      };
    }, [map, inputField, options]);
    return autocomplete;
  };

  /**
   * Hook to get Google Maps Places Directions Service instance
   */

  var useDirections = function useDirections(props) {
    if (props === void 0) {
      props = {};
    }

    var _props = props,
        renderOnMap = _props.renderOnMap,
        renderOptions = _props.renderOptions;

    var _useGoogleMap = useGoogleMap(),
        map = _useGoogleMap.map,
        loading = _useGoogleMap.loading; // Creates a Directions Service instance


    var directionsService = React.useMemo(function () {
      // Wait for map to be initialized
      if (!map || loading) {
        return null;
      }

      return new google.maps.DirectionsService();
    }, [map, loading]); // Creates a Directions Renderer instance

    var directionsRenderer = React.useMemo(function () {
      // Wait for map to be initialized
      if (!map || !renderOnMap) {
        return null;
      }

      var renderer = new google.maps.DirectionsRenderer(renderOptions);
      renderer.setMap(map);
      return renderer;
    }, [map, renderOnMap]); // Updates the directions renderer options

    React.useEffect(function () {
      if (!directionsRenderer) {
        return;
      }

      directionsRenderer.setOptions(renderOptions || {});
    }, [renderOptions]); // Custom Directions route request

    var findRoute = React.useCallback(function (request) {
      return new Promise(function (resolve, reject) {
        if (directionsService) {
          directionsService.route(request, function (result, status) {
            if (status === google.maps.DirectionsStatus.OK) {
              resolve(result);
            } else {
              reject(status);
            }
          });
        }
      });
    }, [directionsService]); // Custom Directions route request followed by directions rendering

    var findAndRenderRoute = React.useCallback(function (request) {
      return new Promise(function (resolve, reject) {
        if (directionsService) {
          directionsService.route(request, function (result, status) {
            if (status === google.maps.DirectionsStatus.OK) {
              if (directionsRenderer) {
                directionsRenderer.setDirections(result);
              }

              resolve(result);
            } else {
              reject(status);
            }
          });
        }
      });
    }, [directionsService, directionsRenderer]); // Renders directions route of given index

    var renderRouteOfIndex = function renderRouteOfIndex(index) {
      if (directionsRenderer) {
        directionsRenderer.setRouteIndex(index);
      }
    };

    return {
      directionsService: directionsService,
      findRoute: directionsService && findRoute,
      findAndRenderRoute: directionsService && directionsRenderer && findAndRenderRoute,
      renderRouteOfIndex: renderRouteOfIndex
    };
  };

  /**
   * Hook to get Google Maps Geocoder instance
   */

  var useGeocoder = function useGeocoder() {
    var _useGoogleMap = useGoogleMap(),
        map = _useGoogleMap.map; // Creates a Geocoder instance


    var geocoder = React.useMemo(function () {
      // Wait for Google Maps API to be initialized
      if (!map) {
        return null;
      }

      return new google.maps.Geocoder();
    }, [map]);
    return geocoder;
  };

  exports.GoogleMapProvider = GoogleMapProvider;
  exports.useAutocomplete = useAutocomplete;
  exports.useDirections = useDirections;
  exports.useGeocoder = useGeocoder;
  exports.useGoogleMap = useGoogleMap;
  exports.usePlacesService = usePlacesService;

})));
